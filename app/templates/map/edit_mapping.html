{% extends 'base.html' %}
{% import 'map/macros.html' as macros %}

{% block title %}{% block header %}矩形データからスペースへのマッピング{% endblock %}{% endblock %}
{% block head %}
<script src="{{ url_for('static', filename='openlayers-v6.9.0/ol.js') }}"></script>
<link rel="stylesheet" href="{{ url_for('static', filename='openlayers-v6.9.0/ol.css') }}">
<style type="text/css">
div.region {
  position: absolute;
  border: 1px solid #333;
  color: rgba(255,0,0,0.5);
  background-color: rgba(255,0,0,0.5);
}
#map {
  height: 100%;
  width: 100%;
  border: 1px #333 solid;
}
#box-container {
  display: flex;
  height: 800px;
}
#box-map{
  height: 100%;
  width: min(100%, 1600px);
}
#box-trace{
  height: 100%;
  width: min(100%, 400px);
  overflow-y: scroll;
}
ul.trace-detail-list {
  display: none;
}
.show-trace-detail-list:checked ~ ul.trace-detail-list {
  display: block;
}
</style>
{% endblock %}

{% block body %}

<section id="box-container">
  <section id="box-map">
    {{ macros.map_with_region(map_regions, map.id) }}
  </section>

  <section id="box-trace">
    <h2>Trace</h2>
    <ul id="trace-list"><ul>
  </section>
</section>

<section>
  <h2>使い方</h2>
  <ol>
    <li>地図上で線を引くと、その線をなぞるように矩形が選択される（trace）</li>
    <li>traceの最初の矩形をどのスペースにするか指定すると、選択された矩形に順にスペースが対応付けられる</li>
    <li>無効にしたいtraceはチェックボックスで無効にできる</li>
    <li>すべてのマッピングが終わったら、下のボタンでマッピングを保存する（時間がかかる。保存したらalertが出る）</li>
  </ol>
  <p><input type="button" id="button_save_mapping" value="マッピングの保存"></p>
  <p><strong>注意：traceはサーバに保存されないのでリロードすると消える</strong></p>
  <p>マッピングし直すときは下のボタンでマッピングを全削除する</p>
  <p><input type="button" id="button_reset_mapping" value="マッピングの全削除"></p>
</section>

<datalist id="space-list">
  {% for space in spaces %}
  <option value="{{ space.name }}">
  {% endfor %}
</datalist>
<template id="trace-list-element">
  <li>
    <input type="checkbox" class="enabled" checked><label class="enabled">trace 2:</label>
    <input type="text" list="space-list" placeholder="あ-01" size="5" class="space-select">
    <input type="checkbox" class="show-trace-detail-list" checked>
    <label>detail</label>
    <ul class="trace-detail-list">
    </ul>
  </li>
</template>
<script>
var g_map;
var g_csrf = "{{ csrf_token() }}";
var g_spaces = [];
{% for space in spaces %}
g_spaces.push({id:"{{ space.id }}", name: "{{ space.name }}"});
{% endfor %}
var g_traces = [];
const selectedStyle = new ol.style.Style({
  fill: new ol.style.Fill({
    color: 'rgba(255, 0, 0, 0.6)',
  }),
  stroke: new ol.style.Stroke({
    color: '#333',
    width: 2,
  }),
});
const hoverStyle = new ol.style.Style({
  fill: new ol.style.Fill({
    color: 'rgba(0, 0, 255, 0.6)',
  }),
  stroke: new ol.style.Stroke({
    color: '#333',
    width: 2,
  }),
});
class Trace {
  static idbase = 0;
  constructor(features) {
    this.features = features;
    this.enabled = true;
    this.spaces = [];
    Trace.idbase++;
    this.id = Trace.idbase;
  }
  setSpaces(firstSpaceName) {
    const spaceStart = g_spaces.findIndex((x) => x.name === firstSpaceName);
    let spaces = g_spaces.slice(spaceStart, spaceStart + this.features.length);
    if (spaces.length !== this.features.length) {
      // 長さ足りん
      return false;
    }
    this.spaces = spaces;
    return true;
  }
  enable() {
    this.enabled = true;
    for (const f of this.features){
      f.setStyle(selectedStyle);
    }
  }
  disable() {
    this.enabled = false;
    for (const f of this.features){
      f.setStyle(undefined);
    }
  }
  hover(i) {
    this.features[i].setStyle(hoverStyle);
  }
  unhover(i) {
    // selectedStyle決め打ちは微妙ではある
    this.features[i].setStyle(selectedStyle);
  }
  save() {
    if (!this.enabled) {
      return Promise.resolve(undefined);
    }
    return Promise.all(this.features.map((f, i) => {
      let region = f.get('model');
      let space = this.spaces[i];
      let data = new FormData()
      data.set('space_id', space.id);
      return fetch(`/region/${region.id}/space`, {
        method: 'POST',
        body: data,
        headers: {
          'X-CSRFToken': g_csrf,
        }
      }).then(response => {
        if (!response.ok) {
          // 失敗したときもとりあえず中身見る
          response.json().then(data => console.log(data));
          throw new Error("矩形からスペースのマッピングの保存に失敗しました");
        }
        return response.json();
      }).then(json => {
        f.set('model', json);
      });
    }));
  }
}
function getDefaultSpaceName() {
  if (g_traces.length > 1) {
    const prevTrace = g_traces[g_traces.length - 2];
    if (prevTrace.spaces.length > 0) {
      const prevLastSpace = prevTrace.spaces[prevTrace.spaces.length - 1];
      if (prevLastSpace !== null && prevLastSpace.name !== null) {
        const spaceStart = g_spaces.findIndex((x) => x.name === prevLastSpace.name);
        if (spaceStart + 1 < g_spaces.length) {
          return g_spaces[spaceStart + 1].name;
        }
      }
    }
  }
  return null;
}
function addTrace(features) {
  if (features.length < 1) {
    // 空なら何もしない
    return;
  }
  let trace = new Trace(features);
  g_traces.push(trace);
  trace.enable();
  // UIへの追加
  var el = document.querySelector("#trace-list-element").content.cloneNode(true);
  var label =el.querySelector("label.enabled");
  label.textContent = "trace " + trace.id + ":";
  var checkbox =el.querySelector("input.enabled");
  checkbox.addEventListener('change', (e) => {
    if(e.target.checked) {
      trace.enable();
    }else {
      trace.disable();
    }
  });
  var select = el.querySelector(".space-select");
  var onchange = (name)=>{
    trace.setSpaces(name);
    var trace_li = select.parentNode.querySelectorAll(".trace-detail-list li");
    trace_li.forEach((li,i) => {
      li.textContent = trace.spaces[i].name;
    });
  }
  select.addEventListener("change", (e) => onchange(e.target.value));
  var tracelist = el.querySelector(".trace-detail-list");
  trace.features.forEach((v,i) => {
    var li = document.createElement("li");
    li.addEventListener('mouseenter', (e) => { trace.hover(i) });
    li.addEventListener('mouseleave', (e) => { trace.unhover(i) });
    tracelist.appendChild(li);
  })
  var spaceName = getDefaultSpaceName();
  if (spaceName) {
    select.value = spaceName;
    onchange(spaceName);
  }
  document.querySelector("#trace-list").appendChild(el);
}
document.querySelector("#button_save_mapping").addEventListener('click', (e) => {
  Promise.all(g_traces.map(tr => tr.save()))
    .then(() => {
      alert("保存しました");
    }).catch(error => {
      alert("保存に失敗しました");
      console.log('error!!!', error);
    });
});
document.querySelector("#button_reset_mapping").addEventListener('click', (e) => {
  if (window.confirm("本当にマッピングを削除しますか")) {
    fetch('/map/{{ map.id }}/region/reset', {
      method: 'DELETE',
      headers: {
        'X-CSRFToken': g_csrf,
      }
    }).then(response => {
      if (!response.ok) {
        // 失敗したときもとりあえず中身見る
        response.json().then(data => console.log(data));
        throw new Error("マッピングの削除に失敗しました");
      }
      return response.json();
    }).then(json => {
      alert("削除しました");
    }).catch(error => {
      alert("保存に失敗しました");
      console.log('error!!!', error);
    });
  }
});
onMapLoad = function(map) {
  g_map = map;

  const source = new ol.source.Vector({wrapX: false});
  const vector = new ol.layer.Vector({
    source: source,
    updateWhileAnimating: true,
    updateWhileInteracting: true,
  });
  map.addLayer(vector);
  const draw = new ol.interaction.Draw({
    source: source,
    type: 'LineString',
  });
  draw.on('drawend', (e) => {
    // 経路を取得
    const line = e.feature.getGeometry();
    let traceFeatures = [];
    const len = line.getLength();
    // 経路上のスペースを集める
    for (var i=0; i<len; i++) {
      var coord = line.getCoordinateAt(i/len);
      var features = getFeaturesAtCoordinate(coord);
      for (const f of features) {
        const model = f.get('model');
        if (! traceFeatures.some((r) => r.get('model').id === model.id)) {
          traceFeatures.push(f);
        }
      }
    }
    console.log(traceFeatures);
    addTrace(traceFeatures);
  });
  map.addInteraction(draw);
};
</script>
{% endblock %}
